Exercise 3 Design
Chas Forelle & Mark Tsao


Data Structures Overview
========================

struct packet {
    int type;       //default is 1
    int process_index;
    int message_index;
    int random_data;
    int payload[1200];
} 

struct done_sending {
    int type;       //default is 2
}


    Each process will contain a simple array structure, which will contain all packets generated by the process, or received from spread.  The process will routinely check if the array is full enough to write to file, so as to avoid too many expensive write operations.


Process Design Overview
=======================

Connecting Phase
----------------
    1. Connect to Spread group
        a. Network already running on ugrad
        b. Group name is predetermined
    2. Wait for all processes to connect to group
        a. num_of_processes is given via command line args
        b. Spread reports back when a machine connects to group
    3. Attach read_message event with HIGH_PRIORITY
        a. On read, put packet into next free array slot
        b. Check to see if packet was from this process, if yes increment a counter
            i. Counter counts up to some number counter_max
                - On first round, counter_max = MAX_BURST_AMOUNT - 1
                - On every subsequent round, counter_max = MAX_BURST_AMOUNT
                - This way, the program knows when to send a new burst of packets into Spread without overloading the daemon and getting disconnected
        c. If counter == counter_max, send a new burst of packets into Spread
        d. Check if queue is full, if yes write queue to file and set array_size = 0
            

Transmission Phase
------------------
    1. Run events until num_sent_messages == num_of_messages
        a. Upon sending all messages, send special done_sending packet
    2. On receive of a done_sending packet, increment done_sending_counter


Termination Phase
-----------------
    a. Program may terminate when done_sending_counter == num_processes
    b. Only need to check if done upon receiving a done_sending packet. Otherwise, wait because not all processes are finished. 



Performance Results
===================

    Running across 8 processes with 6 sending 100,000 packets, this program acheived a time of approximately 17 seconds.  Theoretically this is a transmit performance around 400 mb/s, which is about half the capacity of the Spread network -- assuming no other groups are running code on the same machines at the same time.  Overall, the results are good but could be improved upon to acheive a better time of around 10 - 12 seconds.  The best array size and burst size for this program seemed to be near 1000 and 100, respectively.  The numbers might be able to be optimized a bit, but after tweaking no performance greater than ~1second was observed.  
  
    Interestingly, the program runs in about the same independent of the number of processes. Rather, the number of packets being sent seems to dictate the runtime of the protocol.  If 1 process is run it takes the same amount of time as if 8 processes are run.  This seems to defy logic, as the expected runtime of 1 process would be 8 times faster than 8 processes.  Further investigation is needed to determine the source of this timing discrepancy.
